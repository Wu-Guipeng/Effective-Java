# 第4条：通过私有构造器强化不可实例化的能力

有时候可能需要编写只包含静态方法和静态域的类。例如：以`java.lang.Math`或者`java.util.Arrays`的方式，把基本类型的值或者数组类型上的相关方法组织起来。我们也可以通过`java.util.Collections`的方式，把实现特定接口的对象上的静态方法，包括工厂方法组织起来。最后还可以利用这种类把final类上的方法组织起来，因为不能把它们放在子类中。

这样的工具类不能被实例化，因为实例化对它来说没有任何意义。在缺省构造器的情况下，编译器会自动提供一个公有的、无参的缺省构造器。

企图公国将类做成抽象化来强制不可被实例化是行不通的。该类可以被子类化，子类也可以实例化。只有当类不包含显示的构造器的时候，编译器才会生成缺省和构造器，因此只要让这个类包含一个私有的构造器，它就不能被实例化。

```java
public class UtilityClass{
	// 显示的私有化构造器
	private UtilityClass(){
		throw new AssertionError();
	}
}
```

由于显示的构造器是私有的，所以编译器不会生成缺省的构造器，并且不可以在该类的外部访问它。AssertionError不是必须的，但是它可以避免不小心在类的内部调用构造器。它保证该类在任何情况下都不会被实例化。

这种习惯用法也有副作用，它使得一个类不能把子类化。所有的构造器都必须显示的或者隐式的调用超类构造器，在这种情况下，子类就没有可访问的超类构造器可调用了。