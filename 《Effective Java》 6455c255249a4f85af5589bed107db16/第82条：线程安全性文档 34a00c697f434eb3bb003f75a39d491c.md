# 第82条：线程安全性文档

当一个类的方法被并发使用的时候，这个类的行为如何，是该类与其客户端程序建立的约定的重要组成部分。如果你没有在一个类的文档中描述其行为的并发情况，使用这个类的程序员不得不做出某些假设。如果这些假设是错误的，所得到的程序可能缺少足够的同步，或者过度同步。无论属于这其中哪一种情况，都可能会发生严重的错误。

你可能听到过这样的说法：通过查看文档中是否出现synchronize修饰符，可以确定一个方法是否是线程安全的。这种说法从几个方面来说都是错误的。在正常的操作中，Javadoc并没有在它的输出中包含synchronize修饰符，这是有理由的。因为在一个方法声明中出现synchronize修饰符，这是个实现细节，并不是导出API的一部分。它不一定表明这个方法是线程安全带的。

而且“出现了synchronize关键字就足以用文档说明线程安全性”这种说法隐含了一个错误的观念，即认为线程安全性是一种“要么全有要么全无”的属性。实际上，线程安全性有多种级别。一个类为空可能被多个线程安全地使用，必须在文档中清楚的说明它所支持的线程安全级别。下述分项概括了线程安全性的几种级别。这些分项并没有涵盖所有的可能，只是列出了常见的情形：

- 不可变的（immutable）——这个类的实例是不可变的。所以，不需要外部同步。这样的例子包括String、Long和BIgInteger。
- 无条件的线程安全（unconditionally thread-safe）——这个类的实力是可变的，但是这个类有这足够的内部同步，所以它的实例可以被并发使用，无需任何外部同步。其例子包括AtomicLong和ConcurrentHashMap。
- 有条件的线程安全（conditionally thread-safe）——处理有些方法为进行安全的并发使用而需要外部同步之外，这种线程安全级别与无条件的线程安全相同。这样的例子包括Conllections.synchronize包装放回的集合，它们的迭代器要求外部同步。
- 非线程安全（not thread-safe）——这个类的实例是可变的。为了并发地使用他们，客户端必须利用自己选择的外部同步包围每个方法调用（或者调用序列）。这样的例子包括通用的集合实现，例如ArrayList和HashMap。
- 线程对立的（thread-hostile）——这种类不能安全地被多个线程并发使用，即使所有的方法调用都被外部同步包围。线程对立的根源通常在于，没有同步地修改静态属性。没有人会有意编写一个线程对立的类；这种类是因为没有考虑到并发性而产生的后果。当一个类或者方法被发现是线程对立的，一般会得到修正，或者被标注为“不再建议使用”。第78条中的generateSerialNumber方法就是线程对立的，因为没有从内部进行同步。

这些分类（除了线程对立的之外）粗略对应于《Java Concurrency in Practive》一书中的线程安全注解，分别为Immutable、ThreadSafe和NotThreadSafe。上述分类中无条件和有条件的线程安全都涵盖在ThreadSafe注解中。

在文档描述一个有条件的线程安全类要特别小心。你必须指定那个调用序列需要外部同步，还要指明为了执行这些序列，必须获得哪一把锁（极少的情况下是指哪一把锁）。通常情况下，还是指作用在实例自身上的那把锁，但也有例外。例如，Collections.synchronizeMap文档中有这样的说明：

It is imperative that the user manually synchronize on the returned map when iterating over any of its collection views：当遍历任何被返回的Map集合视图时，用户必须手工对他们进行同步：

```java
Map<K, V> m = Collections.synchronizedMap(new HashMap<>());
Set<K> s = m.keySet();
	...
synchronized(m){
	for(k Key : s)
		key.f();
}
```

如果没有遵守这样的建议，就可能造成不确定的行为。

类的线程安全说明通常放在它的文档注释中，但是带有特殊线程安全的方法则应该在它们自己的文档注释中说明它们的属性。没有必要说明枚举类型的不可变性。除非从返回类型来看已经很明显，否则静态工厂必须在文档说明中返回对象的线程安全，如Collections.synchronizedMap所示。

当一个类承诺“使用一个共有可访问的锁对象”时，就意味着允许客户端以原子的方式执行一个方法调用序列，但是，这种灵活性是要付出代价的。并发集合使用的那种并发控制，并不能与高性能的内部并发空间相兼容。客户端还可以发起拒绝服务攻击，它只需要超时的保持共有可访问锁即可。这有可能是无意的，也可能是有意的。

为了避免这种拒绝服务攻击，应该使用一个私有锁对象来代替同步的一个方法（隐含着一个共有可访问锁）：

```java
private final Object lock = new Object();
public void foo(){
	synchronized(lock){
		...
	}
}
```

因为这个私有锁对象不能在这个类之外被访问，也不能被这个类的客户端程序所访问，所以客户端不可能妨碍对象的同步。实际上，我们正是在应用第15条的建议，把锁对象封装在它们所同步的对象中。

注意lock域被声明为final的。这样可以防止不小心改变它的内容，而导致不同步访问包含对象的悲惨后果。我们这是在引用第17条的建议，将lock域的可变性缩减到最小。lock域应该始终声明为final。这是真的，无论是使用普通的监控锁，还是使用来自java.util.concurrent.locks包中的锁。

私有锁对象模式只能用在无条件的线程安全类上。有条件的线程安全类不能使用这种模式，因为它们必须在文档中说明：在执行某些方面调用序列时，它们的客户端程序必须获得这把锁。

私有锁对象模式特别适用于那些专门为继承二设计的类。如果这种类使用它的实例作为锁对象，子类可能很容易在无意中妨碍基类的操作，反之亦然。处于同样的目的使用同样的锁，子类和基类可能会“互相绊住对方的脚”。这不只是一个理论上的问题。例如，这种现象在Thread类上就出现过。

简而言之，每个类都应该用字斟句酌的说明或者线程安全注解，清楚地在文档中说明它的线程安全属性。synchronize修饰符与这个文档毫无关系。有条件的线程安全类必须在文档中指明“哪个方法调用序列需要外部同步，以及在执行这些序列的时候需要获得哪把锁”。如果你编写的是无条件的线程安全类，就应该考虑使用私有锁对象来代替同步的方法。这样可以防止客户端程序和子类的不同步干扰，让你以后能够在后续的版本中灵活地对并发控制采用更加复杂的方法。