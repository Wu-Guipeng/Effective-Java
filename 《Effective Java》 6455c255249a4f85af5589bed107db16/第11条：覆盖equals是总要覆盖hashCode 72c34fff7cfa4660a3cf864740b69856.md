# 第11条：覆盖equals是总要覆盖hashCode

在每个覆盖了`equals`方法的类中，都必须要覆盖`hashCode`方法。如果不这样做的话，就会违反`hashCode`的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这类集合包括`HashMap`和`HashSet`。下面是约定的内容，摘自`Object`方法：

![Untitled](%E7%AC%AC11%E6%9D%A1%EF%BC%9A%E8%A6%86%E7%9B%96equals%E6%98%AF%E6%80%BB%E8%A6%81%E8%A6%86%E7%9B%96hashCode%2072c34fff7cfa4660a3cf864740b69856/Untitled.png)

- 在应用程序的执行期间，只要对象的`equals`方法的比较操作所用到的信息没有被修改，那么对同一个对象的多次调用，`hashCode`方法都必须始终放回同一个值。在一个应用程序与另一个程序的执行过程中，执行`hashCode`方法所放回的值可以不一致。
- 如果两个对象根据`equals(Object)`方法比较是相等的，那么调用这两个对象中的`hashCode`方法都必须产生通用的整数结果。
- 如果两个对象根据`equals(Object)`方法比较是不相等的，那么调用这两个对象中的`hashCode`方法，则不一定要求`hashCode`方法必须产生不同的结果。但是程序员应该知道，给不相等的对象产出截然不同的整数结果，有可能提高散列表（hash table）的性能.

因为没有覆盖`hashCode`而违反的关键约定是第二条：相等的对象必须具有相等的散列码（hash code）。根据类的`equals`方法，两个截然不同的实例在逻辑上有可能是相等的，但是根据`Object`类的`hashCode`方法，它们仅仅是两个没有任何共同之处的对象。因此，对象的`hashCode`方法返回两个看起来是随机的整数，而不是根据第二个约定所要求的那样，返回两个相等的整数。

假设在`HashMap`中使用第10条中出现过的`PhoneNumber`类的实例作为键：

```java
Map<PhoneNumber, Object> map = new HashMap<>();
map.put(new PhoneNumber(707,123,5309),"jenny");
```

此时你可能希望`map.get(new PhoneNumber(707, 123, 5309));` 会返回`"jenny"`,但它实际上放回的是`null`。注意，这里涉及到了两个`PhoneNumber`实例：第一个被插入到`HashMap`中，第二个实例与第一个实例相等，用于从`Map`中根据`PhoneNumber`去获取用户名字。由于`PhoneNumber`没有覆盖`hashCode`方法，从而导致两个相等的实例具有不相等的散列码，违反了`hashCode`的约定。因此，`put`方法把电话号码对象存放在一个散列桶中，`get`方法却在另一个散列桶中查找这个电话号码。即使两个实例正好被放到同一个散列桶中，`get`方法也必定会返回`null`，因为`HashMap`有一项优化，可以将与每个项相关联的散列码缓存起来，如果散列码不匹配，也就不再去检验对象的等同性（equals）。

修正这个问题非常简单，只需要为`PhoneNumber`类提供一个`hashCode`方法即可。那么，`hashCode`方法因该怎样的呢？编写一个合法但并不好用的`hashCode`方法没有任何价值。例如，下面这个方法总是合法的，但是它永远都不因该被正式使用：

```java
@Override
    public int hashCode() {
        return 47;
    }
```

上面这个`hashCode`方法是合法的，因为它确保了相等的对象总是具有相等的散列码。但它也及其恶劣，因为它使得每一个对象都具有相同的散列码。因此，每个对象都被映射到同一个散列桶中（linked list）。它使得本该线性时间运行的程序变成了以平方级时间在运行。对于很大的散列表而言，这回关系到散列表是否能正常工作。

一个好的散列表通常倾向于“**为不相等的对象产生不相等的散列码**”。这正是`hashCode`约定中的第三条的含义。理想情况下，散列函数应该把集合中不相等的实例均匀的分布到所有可能的`int`值上。想要完全达到这种理想的情形是非常困难的。幸运的是，相对接近这种理想情形则并不太困难。下面给出一种解决办法：

1. 声明一个`int`变量并命名为`result`，将它初始化为对象中第一个关键域的散列码`c`，如步骤2.a中计算所示（如第10条所述，关键域是指影响equals比较的域）。
2. 对象中剩下的每一个关键f都完成以下步骤：
    1. 为该域计算`int`类型的散列码`c`：
        1. 如果该域是基本类型，则计算`Type.hashCode(f)`，这里的`Type`是装箱基本类型的 类，与`f`的类型相对应。
        2. 如果该域是一个引用对象，并且该类的`equals`方法通过递归的调用`equals`的方式来比较这个域，则同样为这个域递归的调用`hashCode`。如果需要更为复杂的比较，则为这个域计算一个“范式”，然后针对这个范式调用`hashCode`，如果这个域的值为`null`，则返回0（或者其他某个常数，通常是0）.
        3. 如果该域是一个数组，则需要把每一个元素当作单独的域来处理。也就是说，递归的应用上述规则，对每个重要的元素计算一个散列码，然后根据步骤2.b中的做法把这些散列值组合起来。如果数组中没有重要的元素，然后可以用一个常量，但最好不要用0。如果数组域中的所有元素都很重要，可以使用`Arrays.hashCode`方法。
    2. 按照下面的公式，把步骤2a中计算得到的散列码`c`合并到`result`中：
        
        ```java
        result = 31 * result + c; 
        ```
        
3. 返回`result`

写完`hashCode`方法之后，问问自己“**相等的实例是否都具有相等的散列码**”。编写单元测试来验证你的推断你。

在散列码的计算过程中，可以把**衍生域**排除在外。换句话说，如果一个域的值可以根据参与计算的其他域值计算出来，则可以把这样的域排除在外。必须排除`equals`比较计算中没有用到的任何域，否则很有可能违反`hashCode`约定的第二条。

步骤2.b中的乘法部分使得散列值**依赖域的顺序**，如果一个类包含多个相似的域这样的乘法运算就会产生一个更好的散列函数。例如，如果`String`散列函数忽略了这个乘法部分，那么只是字母顺序不同的所有字符串将都会有相同的散列码。之所以选择31，是因为它是一个奇素数。如果乘数是偶数，并且乘法溢出的话，信息就会丢失，因为与2相乘等价于位移运算。使用素数的好处并不很明显，但是习惯上都是用素数来计算散列结果。31有个很好的特性，即用位移和减法来代替乘法，可以得到更好的性能：`31 * i == (i << 5)-i`，现代的虚拟机可以自动的完成这种优化。

现在我们将上述解决办法用到`PhoneNumber`类中：

```java
@Override
    public int hashCode() {
        int result = Short.hashCode(areaCode); 
        result = 31 * result + Short.hashCode(prefix); 
        result = 31 * result + Short.hashCode(lineNum);
        return (int) result;
    }
```

因为这个方法返回的是一个简单的、确定的计算结果，它的输入只是`PhoneNumber`实例中的三个关键域，因此相等的`PhoneNumber`实例显然都会有相等的散列码。实际上 ，对于`PhoneNumber`的`hashCode`实现而言，上面这个方法是非常合理的，相当于`Java`平台类库中的实现。它的做法非常简单，也相当快捷，恰当的把不相等的电话号码分散到不同的散列桶中。

`Objects`类有一个静态方法，它带有任意数量的对象，并为它们返回一个散列码。这个方法名为`hash`，是让你只需要编写一行代码的`hashCode`方法，与根据本条目前面介绍的解决方案编出来的相比，它的质量是与之相当的。遗憾的是，运行速度更慢一些，因为它们会引发数组的创建，以便传入数目可变的参数，如果参数中有基本类型，还需要装箱和拆箱。建议只将这类散列函数用于不太注重性能的情况。下面就是这种方法为`PhoneNumber`编写的散列函数：

```java
@Override
    public int hashCode() {
        return Objects.hash(areaCode,prefix,prefix);
    }
```

如果一个类是不可变的，并且计算散列码的开销也比较大，就应该考虑把散列码缓存在对象内部，而不是每次请求的时候都重新计算散列码。如果你觉得这种类型的大多数对象会被用作散列键，就应该在创建实例的时候就计算散列码。否则，可以选择“**延迟初始化**”散列码，即第一次用到`hashCode`被第一次调用的时候才初始化。以`PhoneNumber`类为例：

```java
private int hashCode;

@Override
public int hashCode() {
    int result = hashCode;
    if (result == 0){
        result = Short.hashCode(areaCode);
        result = 31 * result + Short.hashCode(prefix);
        result = 31 * result + Short.hashCode(lineNum);
        hashCode = result;
    }
    return result;
}
```

不要试图从散列码计算中排除掉一个对象那个的关键域来提高性能。虽然这样得到的散列行数运行起来可能会更加块，但是它的效果不见得会很好，可能会导致散列表慢到根本无法使用。特别是在实践中，散列函数可能面临大量的实例，在你选择忽略的区域之中，这些实例仍然区别非常大。如果是这样，散列函数就会把所有这些实例映射到极少数的散列码上，原本应该以线性时间运行的程序 ，将会以平方级的时间运行。

不要对hashCode方法的放回值做任何具体的规定，因此客户端无法理所当然的依赖它；这样可以为修改提供灵活性。`Java`类库中的许多类，比如`String`和`Integer`，都可以把它们的`hashCode`方法返回的确切值规定为该实例值得一个函数。

总而言之，达能覆盖`equals`方法时，都必须覆盖`hashCode`，否则程序将无法正确运行。`hashCode`方法必须遵守`Object`规定得通用约定，并且必须完成一定得工作，将不相等得散列码分配给不相等得实例。