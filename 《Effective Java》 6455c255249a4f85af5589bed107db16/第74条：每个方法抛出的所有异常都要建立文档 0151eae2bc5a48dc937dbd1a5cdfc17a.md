# 第74条：每个方法抛出的所有异常都要建立文档

描述一个方法所抛出的异常，是正确的使用这个方法时所需文档的重要组成部分。因此，花店时间仔细地为每个方法抛出的异常建立文档是特别重要的。

始终要单独地声明受检异常，并且利用Javadoc的@throws标签，准确的记录下抛出每个异常的条件。如果有一个公有方法可能抛出多个异常类，则不要使用“快捷方式”声明它会抛出这些异常的某个超类。永远不要声明一个公有方法直接“throws Exception”，或者更糟糕的是声明它直接“throws Throwable”，这是非常极端的例子。这样的声明不仅没有为程序员提供关于“这个方法能够抛出哪些异常”的任何信息，而且大大的妨碍了该方法的使用，因为它实际上掩盖了该方法在同样的执行环境下可能抛出的任何其他异常。这条建议有一个例外，就是main方法，他可以被安全的声明抛出Exception，因为它只通过虚拟机调用。

虽然Java语言本身并没有要求程序员为一个方法声明它可能会抛出的未收件异常，但是，如同受检异常一样，仔细地为它们建立文档是非常明智的。未受检异常通常代表编程上的错误，让程序员了解所有这些错误都有助于它们避免犯同样的错误。对于方法可能抛出的未收件异常，如果将这些异常信息很好地组织成列表文档，就可以有效地描述出这个方法被成功执行的前提条件。每个方法的文档应该描述她的前提条件，这是很重要的，在文档中记录下来未收件异常是满足前提条件的最佳做法。

对于接口方法，在文档中记录下它们可能抛出的未收件异常显得尤为重要。这份文档构成了该接口的通用约定的一部分，它指定了该接口的多个实现必须遵守的公共行为。

使用Javadoc的@throws标签记录下一个方法可能抛出的每个未受检异常，但是不要使用throws关键字将未受检异常的异常包含在方法的声明中。使用API的程序员必须知道哪些异常时需要受检的，哪些是不需要受检的，因为他们有责任区分这两种情形。当缺少有throws声明产生的方法标头时，由Javadoc的@throws标签所产生的文档就不会提供明显的提示信息，以帮助程序员区分受检异常和未受检异常。

应该注意的是，为每个方法可能抛出的所有未受检异常建立文档都是很理想的，但是在实践中并非总能做到这一点。当类被修订之后，如果有个导出方法被修改了，它将会抛出额外的未受检异常，这不算违反源码或者二进制兼容性。假设一个类调用了另一个独立编写的类中的方法。第一个类的编写者可能会为每个方法抛出的未受检异常仔细地建立文档，但是如果第二个类被修订了，抛出额外的未收件异常，很有可能第一个类（它并没有被修订）就会把新的未受检异常传播出去，尽管他没有声明这些异常。

如果一个类中的许多方法处于同样的原因为抛出同一个异常，在该类的文档注释中对这个异常建立文档，这是可以接收的，而不是为每个方法单独建立文档。一个常见的例子是NullPointerException。若类的文档注释中有这样的描述：“All method in this class throw a NullPointerException if a null object referenct is passed in any parameter”（如果null对象引用被传递到任何一个参数中，这个类中的所有方法都会抛出NullPointerException），或者有其他类似的语句，这是可以的。

总而言之，要为你编写的每个方法所能抛出的每个异常建立文档。对于未受检异常和受检异常，以及抽象的方法和具体的方法一概如此。这个文档在文档注释中应当采用@throws标签的形式。要在方法的throws子句中为每个受检异常提供单独的什么，但是不要声明未受检的异常。如果没有为可抛出的异常建立文档，其他人就很难或者根本不可能有效地使用你的类和接口。