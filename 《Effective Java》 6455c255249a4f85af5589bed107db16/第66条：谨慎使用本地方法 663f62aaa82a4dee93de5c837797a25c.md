# 第66条：谨慎使用本地方法

Java Native Interface（JNI）允许Java应用程序调用本地方法（Navicat method），所谓本地方法是指本地编程语言（比如C或C++）来编写的方法。它们提供了“访问特定于平台的机制”的能力，比如访问注册表（registry）。它们还提供了访问本地遗留代码库的能力，从而可以访问遗留数据。最后本地方法可以通过本地语言，编写应用程序中注重性能的部分，以提高系统的性能。

使用本地方法来访问特定于平台的机制是合法的，但是几乎没有必要：因为随着Java平台的不断成熟，它提供了越来越多以前只有在宿主平台上采拥有的特性。例如，Java 9 增加的进程API，提供了访问操作系统进程的能力。当Java中没有相当的类库可用时，使用本地方法来使用遗留代码库也是合法的。

使用本地方法来提高性能的做法不值得提倡。在早期的发行版本中（Java 3发行版本之前），这样做往往是很有必要的，但是从那以后，JVM实现变得越来越快了。对于大多数任务，现在用Java就可以获得与之相当的性能。举例来说，当Java 1.1发行版本中增加了java.math时，BigInteger是在一个用C编写的快速多精度运算库的基础上实现的。在Java 3发行版本中，BigInteger则完全用Java重新实现了，并且进行了精心的性能调优，运行比原来本地实现更快。

这个故事有一个悲伤的结尾：从那是起，BigInteger几乎没怎么改变，但在Java 8中，大整数却以更快的乘积速度在发展。当时，遗留代码库的工作还在持续快速地发展中，著名的有GNU高精度算术运算库（GNU Multiple Precision GMP）。对于需要真正高性能的高精度算术运算的Java程序员，现在通过本地方法来使用GMP也是无可厚非的。

使用本地方法有一些严重的缺陷。因为本地语言不是安全的，所以使用本地方法的应用程序也不再免受内存毁坏错误的影响。因为本地语言是与平台无关的，使用本地方法的应用程序也不再是可自由移植的。使用本地方法的应用程序也更难调试。如果不小心，本地方法还可能降低性能，因为回收垃圾器不是自动的，甚至无法追踪本机内存使用情况，而且在进入和退出本地代码时，还需要相关的开销。最后一点，需要“胶合代码”的本地方法编写起来也单调乏味，并且难以阅读。

总而言之，在使用本地方法之前务必三思。只有在极少数情况下需要使用本地方法来提高性能。如果你必须要使用本地方法来访问底层的资源，或者遗留代码库，也要尽可能少用本地代码，并且要全面进行测试。本地方法中只要有一个bug都可能破坏整个应用程序。