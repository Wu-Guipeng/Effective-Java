# 第24条：静态成员优于非静态成员类

**嵌套类**是指定义在另一个类的内部的类。嵌套类存在的目的应该只是为了它的外围类提供服务。如果嵌套类将来会用于其他的某个环境中，它就应该是顶层类。嵌套类公有四种：静态成员类，非静态成员类，匿名类，局部类。出来第一种之外，其他三种都称为内部类。

静态成员类是最简单的一种嵌套类。最好把它看作是普通的类，只是碰巧被声明在另一个类中而已，它可以访问外围类的所有成员，包括哪些声明为私有的成员。静态成员类是外围类的一个静态成员，与其他静态成员一样，也遵守同样的可访问性规则。如果它被声明为私有的，他就只能在外围类的内部才可以被访问，等等。

静态成员类的一种常见用法是作为公有的辅助类，只有与它的外部类一起使用才有意义。例如，以枚举类为例，它描述了计算器的各种操作。Operation枚举应该是Calculator类的公有静态成员类，之后Calculator类的客户端就可以用诸如Calculator.Operation.PLUS和Calculator.Operation.MINS这样的名称来引用这些操作。

从语法上将，静态成员类和非静态成员类之间的唯一区别是，静态成员类的声明中包含修饰符static。尽管它们的语法非常相似，但是这两种嵌套类有很大的不同。非静态成员类的每个实例都隐含地与外围类的一个外围实例相关联。在非静态成员类的实例方法内部，可以调用外围实例上的方法，或者利用修饰过的this构造获得外围实例的引用。如果嵌套类的实例可以在它外围类的实例之外独立存在，这个嵌套类就必须是静态成员类：在没有外围实例的情况下，要想创建非静态成员类的实例是不可能的。

当非静态成员类的实例被创建的时候，它和外围实例之间的关联关系也随之被建立起来；而且，这种关联关系以后不能被修改。通常情况下，当外围类的某个实例方法的内部调用了非静态成员类的构造器时，这种关联关系被自动建立起来。使用enclosingInstance.new memberClass(args)来手工建立这种关系也是有可能的，但是很少使用。正如你所预料的那样，这种关系需要消耗非静态成员类实例的空间，而且会增加构造的开销时间。

非静态成员的一种常见的用法时adapter，它允许外部类的实例被看作时另一个不相关的类的实例。例如，Map接口的实现往往使用非静态成员类来实现它们的集合视图，这些集合视图是由Map的keySet、entrySet和values方法返回的。同样的，诸如Set和List这种集合接口的实现往往也是使用非静态成员类来实现它们的迭代器：

```java
public class MySet<E> extends AbstractSet<E> {
    @Override
    public Iterator<E> iterator(){
        return new MyIterator();
    }
    
    private class MyIterator implements Iterator<E>{
		...
    }
}
```

如果声明类成员不要求访问外围实例，就要始终把修饰符（static）放在方法的声明中，使他成为静态成员类，而不是非静态成员类。如果忽略了static修饰符，则每个实例都将包含一个额外的指向外围对象的引用。如前所述，保存这份引用要消耗时间和空间，并且会导致外围实例在复合垃圾回收时却仍然得到保留。由此造成的内存泄漏可能是灾难性的。但常常难以发现，因为这个引用时不可见的。

私有静态成员类的一种常见的用法是代表外围类所代表的对象的组件。以Map实例为例，它把键和值关联起来。许多Map实现的内部都有一个Entry对象，对于Map中的每个键-值对。虽然每个entry都与一个Map关联，当是entry上的方法都不需要访问该Map。因此，使用非静态成员类来表示entry是很浪费的：私有静态成员是最佳的选择。如果不小心漏掉了entry声明中的static修饰符，该Map仍然可以工作，但是每个entry中将会包含一个指向该Map的引用，这样就会浪费空间和时间。

如果相关的类是导出类的公有或者受保护的成员，毫无疑问，在静态和非静态成员之间做出正确的选择是非常重要的。在这种情况下，该成员类就是导出的API元素，在后续的发行版本中，如果不违反向后兼容性，就无法从非静态成员类变为静态成员类。

顾名思义，匿名类是没有名字的。它不是外围类的一个成员。它并不与其他的成员一起被声明，而是在使用的同时被声明和实例化。匿名类可以出现在代码中任何允许存在表达式的地方。当且仅当匿名类出现在非静态的环境中时，它才有外围实例。但是即使它们出现在静态的环境中，也不可能拥有任何静态成员，而是拥有**常数变量**，常数变量是final基本类型，或者被初始化成常量表达式的字符串域。

匿名类的运用受到诸多的限制。除了在它们被声明的时候之外，是无法将它们实例化的。不能执行instanceof测试，或者做任何需要命名类的其他事情。无法声明一个匿名类来实现多个接口，或者扩展一个类，并同时扩展类和实现接口。除了从超类型中继承得到之外，匿名类的客户端无法调用任何成员。由于匿名类出现在表达式中，它们必须保持简短（大约10行或者更少），否则会影响程序的可读性。

在Java中增加lambda之前，匿名类是动态的创建小型函数对象和过程对象的最佳方式，但是现在会优先选择lambda。匿名类的另一种常见的用法是在静态工厂方法的内部。

局部类是四种嵌套类使用最少的类。在任何“可以声明局部变量”的地方，都可以声明局部类，并且局部类也遵守同样的作用域规则。局部类与其他三种嵌套类中的每一种都有一些共同的属性。与成员类一样，局部类有名字，可以被重复使用。与匿名类一样，只有当局部类是在非静态环境中定义的时候，才有外围实例，它们也不能包含静态成员。与匿名类一样 ，它们是非常简短的，不会影响可读性。

总而言之，共有四种不同的嵌套类，每一种都有自己的用途。如果一个嵌套类需要在单个方法之外仍然可见的，或者它长大了，不适合放在方法内部，就应该使用成员类。如果成员类的每个实例都需要一个指向外围实例的引用，就需要把它作为非静态的；否则，就做成静态的。假设这个嵌套类属于一个方法的内部，如果你只需要在一个地方创建实例，并且已经有了一个预置的类型可以说明这个类的特征，就要把它做成匿名类；否则就做成局部类。