# 第26条：请不要使用原生态类型

首先介绍以下术语。声明中具有一个或多个类型参数的类或者接口，就是泛型类或者接口。例如`List`接口就只有单个类型参数`E`，表示列表的元素类型。这个接口的全称是`List<E>`（读作“E的列表”），但是人们经常把它简称为`List`。泛型类和接口统称为泛型。

每一种泛型定义一组参数化的类型，构成格式为：显示类或接口的名称，接着用尖括号（<>）把对应于泛型形式类型参数的实际类型参数列表括起来。例如，`List<String>`（读作字符串列表）是一个参数化的类型，表示元素类型为`String`的列表。（String是与形式参数E相对应的实际类型参数。）

最后一点，每种泛型都定义一个原生态类型，即不带任何实际类型参数的泛型名称。例如，与`List<E>`相对应的原生态类型为`List`。原生态类型就像从类型声明中删除了所有泛型信息一样。它们的存在主要是为了与泛型出现之前的代码相兼容。

在Java增加泛型之前，下面这个集合声明是值得参考的。从Java 9开始，它依然合法，但是已经没有什么参考价值了：

```java
private final Collection stamps = ...;
```

如果现在使用这条声明，并不小心将`coin`放进了`stamp`集合中，这一错误的插入和运行照样可以编译和运行，不会出错（不过编译器确实会发出一条模糊的警告）：

```java
stamps.add(new coin(...));
```

知道从`stamp`集合中获取`coin`时才会收到一条错误提示：

```java
for (Itertor i = stamps.itertor();i.hasNext();){
	Stamp stamp = (Stamp) i.next(); // Throws ClassCastException
		stamp.cancel();
}
```

如本书中经常提到的，出错之后应该尽快发现，最好是在编译时就发现。在本例中，直到运行时才发现错误，已经出错很久了，而且它的代码中所处的位置，距离包含错误的这部分带来已经很远了。一旦发现`ClassCastException`，就必须搜索代码，查找将`coin`放进`stamp`集合的方法调用。此时编译器帮不上忙，因为它无法理解这种注释：“Contains only Stamp instances”（只包含Stamp实例）。

有了泛型之后 ，类型声明中可以包含以下信息，而不是注释：

```java
private final Collection<Stamp> stamps = ...;
```

通过这条声明，编译器知道`stamps`应该只包含`Stamp`实例，并给予保证，假设整个代码库在编译过程中都没有发出任何警告。当`stamps`利用一个参数化的类型声明时，错误的插入会产生一条编译时的错误信息，告诉你具体哪里错了：

```java
Test.java:10: 错误: 不兼容的类型: Coin无法转换为Stamp
        stamps.add(new Coin());
									 ^
```

从集合中检索元素时，编译器会替你插入隐式的转换，并确保它们不会失败（依然假设所有代码都没有产生或者隐瞒任何编译警告）。假设不小心将`coin`插入`stamp`集合，这显得有点牵强，但这类问题确实真实的。例如，很容易想象有人会不小心将一个`BigInteger`实例放入一个原本只包含`BigDecimal`实例的集合。

如上所述，使用原生态类型（没有类型参数的泛型）是合法的，但是永远不应该这么做。如果使用原生态类型，就失掉了泛型在安全性和描述性方面的所有优势。既然不应该使用原生态类型，为什么Java语言设计者还要允许使用它们呢？这是为了提供兼容性。因为泛型出现的时候，Java平台进入它的第二个十年，已经存在大量没有使用泛型的Java代码。人们为了让所有的这些代码保持合法性，并且能够使用泛型和新的代码互用，这一点很重要。它必须合法才能将参数化类型的实例传递给哪些被设计成使用普通类型的方法，反之依然。这种需求被称作为移植性兼容，促成了支持原生态类型，以及利用擦除实现泛型的约定。

虽然不应该在新代码中使用像`List`这一的原生态类型，使用参数化的类型以允许插入任意对象（比如List<Object>）是可行的。原生态类型`List`和参数化类型`List<Object>`之间到底有什么区别呢？不严格的说，前者为了逃避泛型检查，后则则明确的告知编译器，他能够持有任意类型的对象。虽然可以将`List<String>`传递给类型`List`的参数，但是不能将它传递给类型`List<Object>`的参数。泛型有子类型化的规则，`List<String>`类型是原生态的`List`的一个子类型，而不是参数化类型`List<Object>`的子类型。因此，如果使用像`List`这样的原生态类型，就会失掉类型安全性，但是如果使用像`List<Object>`这样的参数化类型，则不会。

为了更具体地进行说明，请参考下面地程序：

```java
public class Test {
    public static void main(String[] args) {
        List<String > strings = new ArrayList<>();
        unsafeAdd(strings,Integer.valueOf(42));
        String s = strings.get(0);

    }

    private static void unsafeAdd(List list, Object o){ // List 参数是原生态类型的
        list.add(o);
    }
}
```

这段程序可以进行编译，但是因为它使用了原生态类型`List`，会收到一条警告信息：

```java
Test.java:15: 警告: [unchecked] 对作为原始类型List的成员的add(E)的调用未经过检查
        list.add(o);
                ^
```

实际上，如果允许这段程序，在程序视图将`strings.get(0)`的调用结果`Integer`转换成`String`时，你会收到一个`ClassCaseException`异常。这是一个编译器生成的转换，因此一般保证成功，但是我们在这个例子中忽略了一条编译器警告，为此付出了代价。

如果在`unsafeAdd`声明中用参数化类型`List<Object>`代替原生类型`List`，并试着重新编译这段程序，并发出以下错误信息：

```java
Test.java:9: 错误: 不兼容的类型: List<String>无法转换为List<Object>
        unsafeAdd(strings,Integer.valueOf(42));
						^
```

在不确定或者不在乎集合中的元素类型的情况下，你也许会使用原生态类型。例如，假设要编写一个方法，它有两个集合，并从中返回共有元素的数量。如果你对泛型还不熟悉，可以参考以下方式来编写这种方法：

```java
static int numElementsInCommon(Set s1, Set s2){
        int result = 0;
        for(Object o1:s1){
            if (s2.contains(o1))
                result++;
        }
        return result;
    }
```

这个方法可行，但是使用了原生态类型，这是很危险的。安全的替代做法时使用**无限制的通配符类型**。如果要使用泛型，但不确定或者不关心实际的类型参数，就可以用一个问好代替。例如，泛型`Set<E>`的无限制通配符类型为`Set<?>`（读作“某个类型的集合”）。这是最普通的参数化`Set`类型，可以持有任何集合。下面是`numElementsInCommon`方法使用无限制通配符类型时的情形：

```java
static int numElementsInCommon(Set<?> s1, Set<?> s2){
        int result = 0;
        for(Object o1:s1){
            if (s2.contains(o1))
                result++;
        }
        return result;
    }
```

无限制通配符类型Set<?>和原生态类型Set之间有什么区别呢？这个问号真正起到作用了吗？这一点不需要赘述，但通配符类型是安全的，原生态类型是不安全。由于可以将任何元素放进原生态类型中的集合中，因此很容易破坏该集合的类型约束条件（如之前范例中的unsafeAdd方法）；但不能将任何元素（除了null之外）放到Collection<?>中。如果尝试这么做，将会产生一条这样的编译时错误消息：

```java
Test.java:10: 错误: 不兼容的类型: String无法转换为CAP#1
        strings.add("test");
                    ^
  其中, CAP#1是新类型变量:
    CAP#1从?的捕获扩展Object
```

这样的错误消息显然无法令人满意，但是编译器已经尽到了它的职责，防止你破坏集合类型约束条件。你不仅无法将任何元素（除了null）放到`Collection<?>`中，而且根本无法猜测你会得到哪种类型的对象。要是无法接受这些限制条件，就可以使用**泛型方法**或者**有限制的通配符类型**。

不要使用原生态类型，这条规则有几个小小的例外。必须在类文字中使用原生态类型。规范不允许使用参数化类型（虽然允许数组类型和基本类型）。换句话说，`List.class`、`String[].class`和`int.class`都合法，但是`List<String>.class`和`List<?>.class`则不合法。

这条规则的第二个例外与`instanceof`操作符有关。由于泛型信息可以在运行时被擦除，因此在参数化类型而非无限制通配符类型上使用`instanceof`操作都是非法的。用无限制通配符类型代替原生态类型，对`instanceof`操作符的行为不会产生任何影响。在这种情况下，尖括号（<>）和问号（?）就显得多余了。下面时利用泛型`instanceof`操作符的首选方法：

```java
if(o instanceof Set){
	Set<?> s = (Set<?>) o;
}
```

注意，一旦这个确定的`o`是个`Set`，就必须将它转换成通配符类型`Set<?>`，而不是转换成原生态类型`Set`。这是个受检的转换，因此不会导致编译时警告。

总而言之，使用原生态类型会在运行时导致异常，因此不要使用。原生态类型只是为了引入泛型之前的遗留代码进行兼容和互用而提供的。让我们做个快速的回顾：Set<Object>是个参数化类型，表示可以包含任何对象类型的一个集合；Set<?>则时一个通配符类型，表示只能包含某种未知对象的一个集合；Set是一个原生态类型，它脱离了泛型系统。前两种是安全的，后一种则是不安全的。

为了便于参考，下表中概括了本条目中所介绍的术语（以及后面将要介绍的属于）：

| 属于 | 范例 |
| --- | --- |
| 参数化类型 | List<String> |
| 实际参数类型 | String |
| 泛型 | List<E> |
| 形式类型参数 | E |
| 无限制通配符类型 | List<?> |
| 原生态类型 | List |
| 有限制类型参数 | <E extends Number> |
| 递归类型参数 | <T extends Comparable<T>> |
| 有限制通配符类型 | List<? extends Number> |
| 泛型方法 | static<E>List<E>asList(E[] a) |
| 类型令牌 | String.class |