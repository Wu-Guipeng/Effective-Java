# 第8条：避免使用终结方法和清除方法

终结方法（finalizer）通常是不可预测的，也是很危险的，一般情况下是不必要的。使用终结方法会导致行为不稳定、性能降低，以及可移植性问题。当然终结方法也有可用之处，将在最后一部分再做介绍：但是根据经验，应该避免使用终结方法。再Java 9中用*清除方法*（cleaner）代替了总结方法。清除方法没有终结方法那么危险，但仍然是不可预测、运行缓慢、一般情况下也是不必要的。

C++的程序员被告知“不要包终结方法当作是C++的析构器的对应物”。在C++中，析构器是回收一个对象所占用资源的常规方法，是构造器所必须的对应物。在Java中，一个对象变得不可到达的时候，

垃圾回收器会回收与该对象相关联的存储空间，并不需要成需要程序员做专门的工作。C++析构器也可以被用来回收其他的非内存资源。而在Java中一般使用`try-finally`块来完成类似的工作。

终结方法和清除方法的缺点在于不能保证会被及时的执行。从一个对象变得不可到达开始，到它得终结方法被执行，所花费得这段时间是任意长得。这意味着注重时间得任务不应该又终结方法或者清除方法来完成。例如，用终结方法或者清楚方法来关闭已经打开得文件，就是一个严重得错误，因为打开文件得描述符是一种很有限得资源。如果系统无法及时得运行终结方法或者清除方法就会导致大量得文件仍然保留打开状态，于是当一个程序再也不能打开文件得时候，它可能会运行失败。

及时的执行终结方法和清除方法正是垃圾回收算法的一个主要功能，这种算法在不同的JVM中大相径庭。如果程序依赖于终结方法或者清除方法被执行的时间点，那么这个程序行为在不同的JVM中运行的表现可能会截然不同。一个程序在你测试用的JVM平台上运行的非常好，一旦部署到生产环境中可能根本无法运行，这是完全有可能的。

Java语言规范不仅不能保证终结方法或者清除方法会被及时的执行，而且根本就不能保证它们会被执行。当一个程序终止的时候，某些已经无法访问的对象上的终结方法却根本没有被执行，这是完全有可能的。结论是：永远不应该依赖终结方法或者清除方法来更新重要的持久状态。例如，依赖终结方法或者清除方法来释放共享资源（比如数据库连接）上的永久锁，这很容易让整个分布式系统垮掉。

使用终结方法的另一个问题是：如果忽略在终结过程中被跑出来的未被捕获的异常，该对象的终结过程也会终止。未被捕获的异常会使对象处于破坏状态，如果另一个线程企图使用这种被破坏的对象，则可能发生任何不确定的行为。正常情况下，未被捕获的异常会将会使线程终止，并打印出栈轨迹，但是，如果异常发生在终结方法之中，则不会如此，甚至连警告都不会打印出来。清除方法则没有这个问题，因为使用清除方法的一个类库在控制它的线程。

使用终结方法和清除方法有一个非常严重的性能损失。

终结方法有一个严重的安全问题：它们为终结方法攻击打开了类的大门。终结方法攻击背后的思想很简单：如果从构造器或者它的序列化对等体抛出异常，恶意子类的终结方法就可以在构造了一部分的应该已经半途夭折的对象上运行。这个终结方法会将该对象的引用记录在一个静态域中，阻止它被垃圾回收。一旦记录到异常的对象，就可以轻松的在这个对象上调用任何原本永远不允许在这里出现的方法。从构造器抛出的异常，应该足以防止这类对象继续存在；有了终结方法的存在，这一点就做不到了。这种攻击会造成致命的后果。final类不会受到终结方法的攻击，因为没有人能够编写出find类的恶意子类。为了防止非final类受到终结方法攻击，要编写一个空的final的finalize方法。

那么，如果类的对象中封装的资源确实需要终止，应该怎样才能做到不用编写终结方法或者清除方法呢？只需让类实现`AutoCloseable`，并要求其客户端在每个实例不在需要的时候调用close方法，一般是利用try-with-resources确保终止，即便遇到异常也是如此。

那么终结方法和清除方法有什么好处呢？它们有两种合法的用途。第一种是，当资源的所有者忘记调用close方法时，终结方法或者清除方法可以充当“安全网”。虽然这样做并不能保证终结方法或者清除方法会被及时的运行，但是在客户端无法正常结束操作的情况下，迟一点释放资源总比永远不释放要好。如果考虑编写这样的安全网终结方法，就要认真考虑清除，这种保护是否值得付出这样的代价。

清除方法的第二种合理用途于对象的本地对等体有关。本地对等体是一个本地（非Java的）对象（native object），普通对象通过本地方法委托给一个本地对象。因为本地对等体不是一个普通对象，所以垃圾回收器不会知道它，当它Java对等体被回收的时候，它不会被回收。如果本地对等体没有关键资源，并且性能也可以接受的化，那么清除方法或者终结方法正式执行这项任务最合适的工具。如果本地对等体拥有必须要被及时终止的资源，或者性能无法接受，那么该类就应该具有一个close方法。

清除方法的是由有一定的技巧。下面是一个简单的Room类为例。假设房间在收回之前必须进行清除。Room类实现了AutoCloseable；它利用清除方法自动清除安全网的过程只不过是一个实现细节。与终结方法不同的是，清除方法不会污染类的公有API：

```java
public class Room implements AutoCloseable {
    private static final Cleaner cleaner = Cleaner.create();

    private static class State implements Runnable{
        int numJunkPiles;

        State(int numJunkPiles){
            this.numJunkPiles = numJunkPiles;
        }

				//由close方法或cleaner调用
        @Override
        public void run() {
            System.out.println("Cleaning room");
            numJunkPiles = 0;
        }

    }

    private final State state;
    private final Cleaner.Cleanable cleanable;

    public Room(int numJunkPiles){
        state = new State(numJunkPiles);
        cleanable = cleaner.register(this,state);
    }
    @Override
    public void close() throws Exception {
        cleanable.clean();
    }
}
```

内嵌的静态类`State`保存清除方法清除房间所需的资源。在这个例子中`num-JunkPilles`域，表示房间的杂乱度。更现实的说，它可以是`final`的`long`，包含一个指向本地对等体的指针。`State`实现了`Runnable`接口，它的`run`方法最多被`Cleanable`调用一次，后者是我们在`Room`构造器中用清除器注册`State`实例获得的。以下两种情况之一会触发`run`方法的调用：通常是通过调用`Room`的`close`方法触发的，后者又调用了`Cleanable`的清除方法。如果到了`Room`实例应该被垃圾回收时，客户端还没有调用`close`方法，清除方法就会（希望如此）调用`State`的`run`方法。

关键是`State`实例没有引用他的`Room`实例。如果它引用了，会造成循环，阻止`Room`实例被垃圾回收（以防止被自动清除）。因此`State`必须是一个静态的嵌套类，因为非静态的嵌套类包含了对其外围实例的引用。同样的也不建议使用`lamdba`，因为它们很容易捕捉到对外围对象的引用。

如前所述，Room的清除方法只有用作安全网。如果客户端将所有的Room实例化都包含在一个try-with-resource块中，将永远不会请求到自动清除。下面是个很好的例子：

```java
public class Test1 {
    public static void main(String[] args) {
        try(Room myRoom = new Room(7)){
            System.out.println("Goodbye");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

正如所期待的那样，运行`Test1`程序会打印出`Goodbye`，接着打印`Cleaning room`。但是下面这个程序就不是这样了:

```java
public class Test1 {
    public static void main(String[] args) {
        new Room(99);
        System.out.println("Peace out");
    }
}
```

它只打印了Peace out，并没有打印`Cleaning room` ，就退出了程序。这就是我们之前提到过的不可预见性。

总而言之，除非是作为安全网，或者是为了终止非关键的本地资源，否则请不要使用清除方法，对于在Java 9之前的版本，则尽量不要使用终止方法。若使用终结方法或者清除方法，则需要注意它的不确定性和性能后果。