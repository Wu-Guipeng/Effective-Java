# 第43条：方法引用优先于Lambda

与匿名类相比，Lambda的主要优势在于更加简洁。Java提供了生成比Lambda更简洁的函数对象的方法：方法引用（method reference）。以下代码片段的源程序是用来保持从任意键到Integer值得一个映射。如果这个值为该键的实例数目，那么这段程序就是一个多集合的实现。这个代码片段的作用是，当这个键不在映射中时，将数字1和键关联起来；或者当这个键已经存在，就负责递增该关联值：

```java
map:merge(key, 1, (count, incr) -> count + incr);
```

注意，这行代码中使用了merge方法，这是Java 8版本在Map接口中添加的方法。如果指定的键没有映射，该方法就会插入指定值；如果有映射存在，merge方法就会将指定的函数应用到当前值和指定值上，并用结果覆盖当前值。这行代码代表了merge方法的典型用例。

这样的代码读起来清晰明了，但仍然有些样板代码。参数count和incr没有添加太多价值，却占用了不少空间。实际上，Lambda要告诉你的是，该函数返回的是它两个参数的和。从Java 8开始，Integer（以及所有其他的数字化基本包装类型都）提供了一个名为sum的静态方法，它的作用同样是求和。我们只要传入一个对该方法的引用，就可以更轻松的得到相同的结果：

```java
map.merge(key, Integer::sum);
```

方法带的参数越多能用方法引用消除的样板代码就越多。但有些Lambda中，即使它更长，但你所选择的参数名称提供了非常有用的文档信息，也会使得Lambda的可读性更强，并且比方法引用更易于维护。

只要方法引用能做的事情，就没有Lambda不能完成的。也就是说，使用方法引用通常能够给得到更加简短的代码、清晰的代码。如果Lambda太长，或者过于复杂，还有另一种选择：从Lambda中提取代码，放到一个新的方法中，并用该方法的一个引用代替Lambda。你可以给这个方法起一个有意义的名字，并用自己满意的方式编写进入文档。有时候，Lambda会比起方法引用更加简洁明了。这种情况大多是当方法与Lambda处在同一个类中的时候。比如下面的代码片段，假定发生在一个名为GoshThisClassNameIsHomogous的类中：

```java
service.execute(GoshThisClassNameIsHomogous::action);
```

Lambda版本的代码如下：

```java
service.execute(() -> action());
```

这个代码片段使用了方法引用，但是它既不比Lambda更简短，也不必它更清晰，因此优先考虑Lambda。类似的还有Function接口，它用一个静态工厂方法返回id函数Function.idetity()。如果它不用这个方法，而是在行内编写等同的Lambda表达式： x → x，一般会比较简洁明了。

许多引用方法都会引用静态方法，但又4种方法引用不引用静态方法。其中两个是有限制和无限制的实例方法引用。在有限制的引用中，接受对象是在方法引用中指定的。有限制的引用本质上类似于静态引用：函数对象于被引用方法带有相同的参数。在无限制的引用中，接受对象是在运用函数对象时，通过该方法的声明函数前面额外添加一个参数来指定的。无限制的引用经常用在管道流中作为映射和过滤函数。最后，还有两种构造器引用，分别针对类和数组。构造器引用时充当工厂对象。这五种方法引用概括如下：

| 方法引用类型 | 范例 | Lambda等式 |
| --- | --- | --- |
| 静态 | Integer::parseInt | str→Integer.parseInt(str) |
| 有限制 | Instant.now()::isAfter | Instant then = Instant.now(); t → them.isAfter(t) |
| 无限制 | String::toLowerCase | str → str.toLowerCase() |
| 类构造器 | TreeMap<K,V>::new | () → new TreeMap<K,V> |
| 数组构造器 | int[]::new | len → new int[len] |

总而言之，方法引用常常比Lambda表达式更加简洁明了。只要方法引用更加简洁、清晰，就用方法引用；如果方法引用并不简洁，就坚持使用Lambda。