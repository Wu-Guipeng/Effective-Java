# 第50条：必要时进行保护性拷贝

Java用起来如此舒适的一个因素在于，它是一门安全的语言。这意味着，它对于缓冲区溢出、数组越界、非法指针以及其他的内存破坏错误的自动免疫，而这些错误却困扰着C和C++这样的不安全语言。在一门安全语言中，在设计类的时候，可以确切的知道，无论系统的其他部分发生什么问题，这些类的约束都可以保持为真。对于哪些“把左右内存当作一个巨大的数组来对待”的语言来说，这是不可能的。

即使在安全的语言中，如果不采取一点措施，还是无法与其他的类隔离开来。假设类的客户端会尽其所能来破坏这个类的约束条件，因此你必须保护性的设计程序。实际上，只有当有人视图破坏系统的安全性时，才可能发生这种情形；更有可能的时，对你的API产生误解的程序员，所导致的各种不可预期的行为，只要由类来处理。无论是哪一种情况，编写一些面对客户的不良行为时仍然能保持健壮性的类，这是非常值得投入时间去做的事情。

如果没有对象的帮助，另一个类不可能修改对象的内部状态，但是对象很容易在无意识的情况下提供这种帮助。例如，以下面的类为例，它声称可以表示一段不可变的时间周期：

```java
public class Period {
    private final Date start;
    private final Date end;

    /**
     * 
     * @param start the beginning of the period
     * @param end the end of the preiod; must not precede start
     * @throws NullPointerException if start or end is null
     */
    public Period(Date start, Date end){
        if(start.compareTo(end) > 0){
            throw new IllegalArgumentException(start + " after " + end);
        }
        this.start = start;
        this.end = end;
    }
    
    public Date start(){
        return start;
    }
    
    public Date end(){
        return end;
    }
}
```

乍看之下，这个类似乎是不可变的，并且加强了约束条件：周期的起始时间（start）不能再结束时间（end）之后。然而，因为Date类本身是可变的，因此很容易违反这个约束条件：

```java
Date start=  new Date();
Date end=  new Date();
Period p = new Period(start, end);
end.setYear(78);
```

从Java 8开始， 修正这个问题最明显的方式是使用Instant（或LocalDateTime，或者ZonedDateTime）代替Date，因为Instant是不可变的。Date已经过时了，不应该在新的代码中使用。也就是说，问题依然存在：有时候，还是需要在API和内部表达式中使用不可变的值类型。

为了保护Period实例的内部信息避免受到这种攻击，对于构造器的每个可变参数（非final）进行保护性拷贝是必要的，并且使用备份对象作为Period实例的组件，而不适用原始的对象：

```java
public Period(Date start, Date end){
    this.start = new Date(start.getTime());
    this.end = new Date(end.getTime());
    
    if(start.compareTo(end) > 0){
        throw new IllegalArgumentException(start + " after " + end);
    }
}
```

用了新的构造器之后，上述的攻击对于Period实例不再有效。注意，保护性拷贝是在参数的有效性之前进行的，并且有效性检查时针对拷贝之后的对象，而不是针对原始的对象。虽然这样做看起来优点不太自然，却是有必要的。这样做可以避免在“危险阶段”期间从另一个线程改变类的参数，这里的危险阶段时值从检测参数开始，知道拷贝参数之间的时间段。在计算机安全社区中，这被称作TimeOfCheck/TimeOfUse或者TOCTOU攻击。

同时也要注意，我们没有用Date的clone方法来进行保护性拷贝。因为Date是非final的，不能保证clone方法一定返回类为java.util.Date对象：它有可能返回专门处于恶意的目的而设计的不可信子类的实例。例如，这样子的类可以在每个实例被创建的时候，把指向该实例的引用记录到一个私有的静态列表中，并且允许攻击者访问这个列表。浙江使得攻击者可以自由的控制所有的实例。为例阻止这种攻击，对于参数类型可以被不可信任方子类化的参数，请不要使用clone方法进行保护性拷贝。

虽然替换构造器就可以成功地避免上述地攻击，但是改变Period实例仍然是有可能地，因为它的访问方法提供了对其可变内部成员访问的能力：

```java
Date start=  new Date();
Date end=  new Date();
Period p = new Period(start, end);
p.end().setTime(78);
```

为了防御者第二种攻击，只需要修改这两个访问方法，使它返回可变内部域的保护性拷贝：

```java
public Date start(){
    return new Date(start.getTime());
}

public Date end(){
    return new Date(end.getTime());
}
```

采用了新的构造器和新的访问方法之后，Period真正是不可变的了。不管程序员是多么恶意，或者多么不合格，都绝对不会违反“周期的起始时间不能万余结束时间”这个约束条件。确实如此，因为除了Period类自身之外，其他任何类都无法访问Period实例中的任何一个可变域。这些域被真正封装在对象的内部。

访问方法与构造器不同，它们在进行保护性拷贝的时候允许使用clone方法。之所以如此，是因为我们知道，Period内部的Date对象的类型是java.util.Date，而不可能是其他某个潜在的不可信子类。也就是说，基于第13条中所阐述的原因，一般情况下，最好使用构造器或者静态工厂。

参数的保护性不仅仅针对不可变类。每当编写方法或者构造器时，如果它允许客户端提供的对象进入到内部数据结构中，则有必要考虑以下，客户提供的对象是否有可能是可变的。如果是，就要考虑类是否能够容忍对象进入数据结构之后发生变化。如果答案是否定的，就必须对该对象进行保护性拷贝，并且让拷贝之后的对象而不是原始对象进入到数据结构中。

在内部组件被返回给客户端之前，对它们进行保护性拷贝也是同样的道理。不管类是否为不可变的，在把一个指向内部可变组件的引用返回给客户端之前，也应该加倍认真的考虑。解决方案是，应该返回保护性拷贝。记住长度非零的数组总是可变的。因此，在把内部数据返回给客户端之前，总要进行保护性拷贝。另一种解决方案是，给客户端返回该数组的不可变视图。这两种方法都在第15挑中演示过了。

可以肯定的说，上述的真正启示在于，只要有可能都应该使用不可变的对象作为对象内部的组件，这样就不必再为保护性拷贝操心。在前面的Period例子中，使用了Instant（或LocalDateTime，或者ZonedDateTime），除非使用Java 8之前的版本。如果使用的是较早的版本 ，一种选择是保存Date.getTime()返回的long基本类型，而不是使用Date对象引用。

保护性拷贝可能会带来相关的性能损失，这种说法并不总是正确的。如果类信任它的调用者不会修改内部的组件，可能因为类及其客户端都是同一个包的双方，那么不进行保护必拷贝也是可以的。在这种情况下，类的文档中就必须清楚的说明，调用者绝对不能修改受到影响的参数或者返回值。

即使跨越报的作用范围，也并不总是合适在将可变参数整合到对象中之前，对它进行保护性拷贝。有一些方法和构造器的调用，要求参数所引用的对象必须由个显示的交接过程。但客户调用这样的方法时，它承诺以后不再直接修改该对象。如果方法或者构造器期望接管一个由客户端提供的可变对象，它就必须在文档中明确地指明这一点。

如果类所包含地方法或者构造器地调用需要移交对象地控制权，这个类就无法让自身抵御恶意地客户端。只有当类和它地客户端之间有着互相地信任，或者破坏类的约束条件不会伤害到客户端之外的其他对象时，这种类才是可以接受的。后一种情形的例子是包装类模式。根据包装类的本质本质特征，客户端只需要在对象被包装之后直接访问，就可以破坏包装类的约束条件，但是，这么做往往只会伤害到客户端自己。

简而言之，如果一个类包含由从客户端得到或者返回到客户端的可变组件，这个类就必须保护性的拷贝这些组件。如果拷贝的成本受到限制，并且类信任它的客户端不会不恰当地修改组件，就可以在文档中指明客户端的指责是不得修改受到影响的组件，以此来代替保护性拷贝。