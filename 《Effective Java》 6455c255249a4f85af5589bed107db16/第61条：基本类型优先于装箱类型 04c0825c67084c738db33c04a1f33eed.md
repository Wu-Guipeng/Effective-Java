# 第61条：基本类型优先于装箱类型

Java有一个类型系统由两部分组成，它包含基本类型（primitive），如int、double和boolean，以及引用类型（reference type），如String和List。每个基本类型都有一个对应的引用类型，称作**装箱类型**（boxed primitive）。装箱类型中对应于int、double和boolean的分别是Integer、Double和Boolean。

如第6条中提到的，自动装箱（autoboxing）和自动拆箱（auto-unboxing）模糊了当没有完全抹去基本类型和转向类型之间的区别。这两种类型之间真正是有差别的，要是清楚再使用的是哪种类型，并且要对这两种类型进行谨慎的选择，这些都是非常重要。

在基本类型和装箱基本类型之间有三个主要的区别。第一，基本类型只有值，而装箱类型则具有与他们的值不同的同一性。换句话说，两个装箱基本类型可以具有相同的值和不同的同一性。第二，基本类型只有函数值，而每个装箱基本类型则都有一个非函数值，处理它对应基本类型的所有函数值之外，还有个null。最后一点区别是，基本类型通常比装箱类型更节省时间和空间。如果不小心，这三点区别都会让你陷入麻烦之中。

以下面这个比较器为例，它被设计用来表示Integer值得递增数字顺序。回想一下，比较器得compare方法返回得数值到底为负数、零还是正数，要取决于它的第一个参数是小于、等于还是大于 它地第二个参数。在实践过程中不需要你编写这个在Integer中实现自然顺序地比较器，因为这是不需要比较器就可以得到地，但它展示了一个有趣地例子：

```java
Comparator<Integer> naturalOrder = (i, j) -> (i < j) ? -1 : (i == j ? 0 : 1);
```

这个比较器表面看起来似乎不错，它可以通过许多测试。例如，它可以通过Collections.sort正确地给一个有100万个元素地列表进行排序，无论这个列表中是否包含重复地元素。但是这个比较器有着严重地缺陷。如果你要让自己信服，只要打印naturalOrder.Compare(new Integer(42), new Integer(42))的值便可以分晓。这两个Integer实例都表示相同的值（42），因此这个表达式的值应该为0，但它输出的确实1，这表明第一个Integer值大于第二个。

问题出在哪呢？naturalOrder中的第一个测试工作的很好。对于表达式i < j 执行计算会导致i和j引用的Integer实例被自动拆箱；也就是说，它提取了它们的基本类型值。计算动作要检查产生的第一个int值是否小于第二个。但是假设答案是否定的。下一个测试就是执行计算i==j，它在两个对象引用上执行同一性比较。如果i和j引用表示同一个int值得不同得Integer实例，这个比较操作就会返回false，比较器会错误得返回1，表示第一个Integer值大于第二个。对于装箱基本类型运用==操作符几乎总是错误的。

事实上，如果需要用比较器描述一个类型的自然顺序，只要调用Comparator.naturalOrder ()即可，如果自己编写的比较器，则应该使用比较构造方法，或者在基本类型上使用静态比较方法。也就是说，修正这个问题的做法是添加两个局部遍历，来保存对应于Integer参数的基本类型int值，并在这些变量上执行多有的比较操作。这样可以避免大量的同一性比较：

```java
Comparator<Integer> naturalOrder = (iBoxed, jBoxed) -> { 
    int i = iBoxed, j = jBoxed; 
    return (i < j) ? -1 : (i == j ? 0 : 1);
};
```

接下来，看看下面这个小程序：

```java
public static void main(String[] args) {
    if(i == 42){
        System.out.println("Unbelievable");
    }
}
```

它不会打印出Unbelievable——但是它的行为也是很奇怪的。它在计算表达式（i == 42）的时候抛出NullPointerException异常。问题在于，i是个Integer，而不是int，就像所有的对象引用域一样，它的初始值为null。当程序计算表达式（i == 42）时，它会将Integer与int进行比较。几乎在任何一种情况下，当在一项操作中混合使用基本类型和装箱基本类型时，装箱基本类型就会自动拆箱，这种个情况无一例外。如果对null对象引用被自动拆箱，就会抛出一个NullPointerException异常。如果这个程序所示，它几乎可以在任何位置发生。修正这个问题很简单，什么i是个int而不是Integer即可。

最后，以第6条中的这个程序为例：

```java
public static void main(String[] args) {
    Long sum = 0L;
    for (long i = 0; i < Integer.MAX_VALUE; i++){
        sum += i;
    }

    System.out.println(sum);
}
```

这个程序运行起来比预计的要慢一些，因为它不小心将一个局部变量（sum）声明为是装箱基本类型Long，而不是基本类型long。程序编译器来没有错误或者警告，变量被反复的装箱和拆箱，导致明显的性能下降。

本条目中的这三个程序中，问题都是一样的：程序员忽略了基本类型和装箱基本类型之间的区别，并尝到了苦头。在前两个程序中，器结果是彻底失败的；在第三个程序中，则有严重的性能问题。

那么什么时候应该使用装箱基本类型呢？它们有几个合理的用处。第一个是作为集合中的元素、键和值。你不能将基本类型放在集合中，因此必须使用装箱基本类型。这是一种更通用的特例。在参数化类型和方法中，必须使用装箱基本类型作为类型参数，因为Java不允许使用基本类型。例如，你不能将变量声明为ThreadLocal<int>类型，因此，必须使用ThreadLocal<Integer>代替。最后，在进行放射的方法调用时，必须使用装箱类型。

总而言之，当可以选择的时候，基本类型要优先于装箱基本类型。基本类型更加简单，也更加快速。如果必须使用装箱基本类型，要特别小心！自动装箱减少了使用装箱基本类型的烦琐性，但是没有减少它的风险。当程序用==操作符比较两个装箱基本类型时，它做了一个同一性比较，这几乎肯定不是你所期望的。当程序进行设计装箱和拆箱操作的混合类型时，它会进行拆箱，当程序进行拆箱时，会抛出NullPointerException异常。最后，当程序装箱了基本类型值时，会导致较高的资源消耗和不必要的对象创建。