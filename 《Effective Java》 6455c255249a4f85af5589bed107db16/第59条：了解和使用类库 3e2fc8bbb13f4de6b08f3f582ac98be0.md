# 第59条：了解和使用类库

假设你希望产生位于0和某个上界之间的随机整数。面对这个常见的任务，许多程序员会编写如下所示的方法：

```java
static Random rnd = new Random();

static int random(int n){
	return Math.abs(rnd.nextInt()) % n;
}
```

这个方法看起来不错，但是却又三个缺点，第一个缺点，如果n是一个比较小的2的乘方，经过一段相当短的周期之后，它产生的随机数序列将会重复。第二个缺点，如果n不是2的乘方，那么平均起来，有些数会比其他的数出现的更为频繁。如果n比较大，这个缺点就会非常明显。这可以通过下面程序直观地体现出来，它会产生100万个精心指定地范围内地随机数，并打印出有多个数字落在随机数取值范围地前半部分：

```java
public static void main(String[] args){
	int n =2 * (Integer.MAX_VALUE /3);
	int low = 0;
	for (int i = 0; i < 1000000; i++)
		if(random(n) < n/2)
			low++;

	System.out.println(low);
}
```

如果random方法工作正常，这个程序打印出来地数将接近100万的一半，但是如果真正运行这个程序，就会发现它打印出来的数接近于666666。由random方法产生的数字有三分之二落在随机数值范围的前半部分。

random方法的第三个缺点是，在极少数情况下，它的失败是灾难性的，因为会返回一个落在指定范围之外的数。之所以如此，是因为这个方法试图通过调用Math.abs，将rnd.nextInt()返回的值映射为一个非负整数int。如果nextInt()返回Integer.MIN_VALUE，将返回一个负数。这几乎肯定会使程序失败，而且这种失败很难重视。

未了编写修正这三个缺点的random方法，有必要了解关于同余伪随机数生成器、数论和2的求补算法的相关知识。幸运的是，你并不需要自己来做这些工作——已经有现成的成果可以为你所用。这一成果被称作为Random.nextInt(int)。你无需关系nextInt(int)的实现细节。具有算法背景的高级工程师已经话费了大量的实践来设计、实现和测试这个方法，然后经过这个领域中的专家的审查，以确保它的正确性。之后，标准类库经过了Bate测试并正式发行，几年之间已经有成千上万的程序员在使用它。这份方法中没有发现过缺陷，但是，如果将来发现有缺陷，在下一个版本中就会修正这些缺陷。通过使用标准类库，可以充分利用这些标准类库的专家的知识，以及在你之前的其他人的使用经验。

从Java 7开始，就不应该使用Random了。现在选择随机数生成器时，大多使用ThreadLocalRandom。它会生产出更高质量的随机数，并且速度非常块。在我的机器上比Random快了3.6倍。对于Fork Join Pool和并行Stream，则使用SplittableRandom。

使用标准类库的第二个好处是，不必浪费实践为那些与工作不太相关的问题提供特别的接近方案。像大多数程序员一样，应该把时间花在应用程序上，而不是底层的细节上。

使用标准类库的第三个好处是，它们的性能往往会随着实践的推移而不断提高，无须做任何努力。因为许多人在使用它们，并且是当作工业标准在使用，所以提供这些标准类库的组织有强烈的动机要使它们运行的更快。这些年来，许多Java平台类库已经倍重新编写了，有时候是重复编写，从而在性能上有了显著的提高。

使用标准类库的第四个好处是，它们会随着时间的推移而增加新的功能。如果类库中漏掉了某些功能，开发者社区就会把这些缺点公示出来，漏掉的功能就会添加到后续的发行版本中。

使用标准类库的最后一个好处是，可以使自己的代码融入主流。这样的代码更容易阅读、更易维护、更易被大多数的开发人员重用。

既然有那么多的优点，使用标准库机制而不选择专门的实现，者显然使符合逻辑的，然而还是有相当一部分的程序员没有这么做。为什么呢？可能它们并不知道有这些类库机制的存在。在每个重要的发行版本中，都会有许多新的特性被假如到类库中，所以与这些特性保持同步是值得的。每当Java平台有重要的发行时，都会发布一个网页来说明新的特性。这些网页值得好好读一读。

这些标准类库太庞大了，以至于不可能学完所有的文档，但是每个程序员都应该熟悉java.lang、java.util、java.io及其子包中的内容。关于其他类库的知识可以根据随时学习。

其中有几个类库值得一提。Collections Framework（集合框架）和Stream类库应该成为每一个程序员基本工具箱的一部分，同样也应该成为java.util.concurrent中并发机制的组成部分。这个包既包含高级的并发工具来简化多线程的编程任务，还包含低级别的并发基本类型，允许专家们自己编写更高级的并发抽象。

在某些情况下，一个类库工具并不能满足你的需求。你的需求越特殊，这种情形就越有可能发生。虽然你的第一个念头应该是使用标准库，但是，如果你在观察了它们的某些领域所提供的功能之后，确定它不能满足需求，你就得使用其他实现。任何一组类库所提供的功能难免会有遗漏。如果你在Java类库中找不到所需要的功能，下一个选择应该是在高级的第三方类库中寻找，比如Google优秀的开源Guava类库。如果在所有相应的类库中都无法找到你所需要的功能，就只能自己实现这些功能了。

总而言之，不要重复发明轮子。如果你做的事情十分常见，有可能类库中已经有某个类完成了这样的工作。如果确实是这样，就使用现成的；如果还不清楚是否存在这样的类，，就去查一查。一般而言，类库的代码可能比你自己编写的代码更好一些，并且不会随着时间的推移而不断改进。这并不是质疑你作为一个程序员的能力。从经济的角度分析表明：类库代码受到的关注远远超过大多数普通程序员在同样的功能上所能给予的投入。