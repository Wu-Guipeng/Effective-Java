# 第76条：努力使失败保持原子性

当对象抛出异常之后，通常我们期望这个对象仍然保持在一种定义良好的可用状态之中，即使失败是发生在执行某个操作的过程中间。对于受检异常而言，者尤为重要，因为调用者期望能从这种异常中进行恢复。一般而言，失败的方法调用应该使对象保持在被调用之前的转状态。具有这种属性的方法被称为具有**失败原子性**。

有几种用途可以实现这种效果。最简单的办法莫过于设计一种不可变的对象。如果对象时不可变的，失败原子性就是显然的。如果一个操作失败了，它可能会阻止创建新的对象，但是永远也不会使已有的对象保持在不一致的状态之中，因为当每个对象被创建之后她就处于一致的状态之中，以后也不会发生变化。

对于在可变对象上执行操作的方法，获得失败原子性最常见的办法是，在执行操作之前检查参数的有效性。这可以使得在对象的状态被修改之前，先抛出适当的异常。比如，以第七条中的Stack.pop方法为例：

```java
public Object pop(){
    if(size == 0)
        **throw new EmptyStackException();**
    Object result = elements[--size];
    elements[size] = null;
    return result;
}
```

如果取消对初始大小（size）的检查，当这个方法企图从一个空栈中弹出一个元素时，它仍然会抛出异常。然而，这将会导致size域保持在不一致的状态之中，从而导致将来对该对象的任何方法调用都会失败。此外，那时，pop方法抛出的ArrayIndexOutOfBoundsEcxeption异常对于该抽象来说也是不恰当的。

一种类似的获得失败原子性的办法是，调整计算处理过程的顺序，使得任何可能会失败的计算部分都在对象状态被修改之前发生。如果对参数的检查只有在执行了部分计算之后才能进行，这种办法实际上就是上一种办法的自然扩展。比如，以TreeMap的情形为例，它的元素被按照某种特定的顺序做了排序。为了向TreeMap中添加元素，改元素的类型就必须是可以利用TreeMap的排序准则与其他元素进行比较的。如果企图增加类型不正确的元素，在tree以任何方式被修改之前，自然会导致ClassCastException异常。

第三种获得失败原子性的办法是，在对象的一份临时拷贝上执行操作，当操作完成时候再用临时拷贝中的结果代替对象的内容。如果数据保存在临时的数据结构中，计算过程会更加迅速，使用这种办法就是很自然的事。例如，有些排序函数会在执行排序之前，先把它的输入列表备份到一个数组中，以便降低在排序的内循环中访问元素所需要的开销。这是处于性能考虑的做法，但是，它增加了一项优势：即使排序失败，它也能保证输入列表保持原样。

最后一种获得失败原子性的办法远远没有那么常用，做法是编写一段恢复代码，由它来拦截操作过程中发生的失败，以及使对象回滚到操作开始之前的状态上。这种办法主要用于永久性的数据结构。

虽然一般情况下都希望实现失败原子性，但并非总是可以做到。举个例子，如果两个线程企图在没有适当的同步机制的情况下，并发地修改同一个对象，这个对象就有可能被留在不一致的状态之中。因此，在捕获了ConcurrentModificationException异常之后再假设对象任然是可用的，这就是不正确的。错误通常是不可恢复的，因此，当方法抛出AssertionException使，不需要努力去保持失败原子性。

总而言之，作为方法规范的一部分，它产生的任何异常都应该让对象保持在调用改方法之前的状态。如果违反了这条规则，API文档就应该清楚地指明对象会处于什么样的状态。遗憾的是，大量现有的API文档都未能做到这一点。