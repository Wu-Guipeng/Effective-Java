# 第17条：使可变性最小化

不可变类是指其实例不被修改的类。每个实例中包含的所有信息都必须在创建该实例的时候就提供，并在对象的整个声明周期内不固定。Java平台类库中包含许多理由不可变的类，其中有`String`、基本类型的包装类、`BigInteger`和`BigDecimal`。存在不可变的类有许多理由：比可变的类更加易于设计、实现和使用。它们不容易出错，且更加安全。

为了使类成为不可变，要遵循下面五条规则：

1. 不要提供任何会修改对象状态的方法（也称为设值方法）。
2. 保证给类不会被扩展。这样可以防止粗心或则恶意子类假装对象的状态已经改变，从而破坏该类的不可变行为。为了防止子类化，一般做法使声明这个类成为`final`的。
3. 声明所有的域都是final的。通过系统的强制方式可以清楚的表明你的意图。而且，如果指向一个新创建实例的引用在缺乏同步机制的情况下，从一个线程被传递到另一个线程，就必须确保正确的行为，正如内存模型中所述。
4. 声明所有的域都是私有的。这样可以防止客户端获得访问访问域引用的可变对象的权限，并防止客户端直接修改这些对象。虽然从技术上来说，允许不可变的类具有公有的`final`域，只要这些域包含基本数据类型的值或者指向不可变对象的引用，但是不建议这样做，因为这样会使得以后再版本中无法改变内部的表示法。
5. 确保对于任何可变组件的互斥访问。如果类具有指向可变对象的域，则必须确保该类的而客户端无法获得指向这些对象的引用。并且，永远不要用客户端提供的对象引用来初始化这样的域，也不要从任何访问方法中返回该对象的引用。在构造器、访问方法和`readObject`方法中使用**保护性拷贝**技术。

前面条目中的许多例子都是不可变的，其中一个例子是第11条中的`PhoneNumber`，它针对每个属性都有访问方法，但是没有对应的设值方法。下面是个稍微复杂一点的例子。

```java
public final class Complex {
    private final double re;
    private final double im;

    public Complex(double re, double im){
        this.re = re;
        this.im = im;
    }

    public Complex plus(Complex c){
        return new Complex(re + c.re, im + c.im);
    }

    public Complex minus(Complex c){
        return new Complex(re - c.re, im - c.im);
    }

    public Complex times(Complex c){
        return new Complex(re * c.re - im * c.im, re * c.im + im * c.re);
    }

    public Complex divideBy(Complex c){
        double tmp = c.re * c.re + c.im + c.im;
        return new Complex((re * c.re + im * c.im) / tmp,
                           (im * c.re - re * c.im) / tmp);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (!(o instanceof Complex))
            return false;

        Complex complex = (Complex) o;
        return Double.compare(complex.im, im) == 0
            && Double.compare(complex.re, re) == 0;
    }

    @Override
    public int hashCode() {
        return 31 * Double.hashCode(re) + Double.hashCode(im);
    }

    @Override
    public String toString(){
        return "(" + re + " + " + im + "i)";
    }
}
```

这个类表示一个复数（complex number ，具有实部和虚部）。除了标准的`Object`方法之外，它还提供了针对实部和虚部的访问方法，以及4中基本的算术运算：加法、减法、乘法和除法。注意这些算术运算如何创建并返回新的`Complex`实例，而不是修改这个实例。大多数重要的不可变类都使用了这种模式。它被称为**函数的方法，**因为这些方法返回了一个函数的结果，这些函数对操作数进行运算但并不修改它。与之相对应的更为常见的是**过程的**或者**命令式的**方法，使用这些方法时，将一个过程作用在操作数上，会导致它的状态发生变化。注意，这些方法名称都是介词（如plus），而不是动词（add）。这是为了强调该方法不会改变对象的值。

如果你对函数方式的做法还不太熟悉，可能会觉得它显得不太自然，但是它带来了不可变性，具有许多优点。不可变对象比较简单。不可变对象只有一种状态，即被创建时的状态。如果你能够确保所有的构造器都建立了这个类的约束关系，就可以确保这些约束关系在整个声明周期内永远不再发生变化，你和使用这个类的程序员都无需再做额外的工作来维护这些约束关系。另一方面，可变对象可以有任意复杂的状态空间。如果文档中没有为设置方法所执行的状态转换提供精确的描述，要可靠地使用可变类是非常困难的，甚至是不可能的。

不可变对象本质上是线程安全的，它们不要求同步。当多个线程并发访问这样的对象时，它们不会遭到破坏。这无疑是获得线程安全最容易的办法。实际上，没有任何线程会注意到其他线程对于不可变对象的影响。所以，不可变对象可以被自由地共享。不可变类应该充分利用这种优势，鼓励客户端尽可能地重用现有的实例。要做到这一点，一个很简单地办法就是：对于频繁用到地值，为它们提供公有地静态`final`常量。例如，Complex类有可能会提供下面地常量：

```java
public static final Complex ZERO = new Complex(0,0);
public static final Complex ONE  = new Complex(1,0);
public static final Complex I    = new Complex(0,1);
```

这种方法可以被进一步扩展。不可变地类可以提供一些静态工厂，它们把频繁被请求地实例缓存起来，从而当现有实例可以符合请求的时候 ，就不必创建新地实例。所有基本类型和包装类和`BigInteger`都有这样的静态工厂。使用这样的静态工厂也使得客户端之间可以共享现有的实例，而不用创建新的实例，从而降低内存占用和垃圾回收的成本。在设计类的时候，选择用静态工厂代替公有的构造器可以让你以后有添加缓存的灵活性，而不必影响客户端。

“不可变对象可以被自由的共享”导致的结果是，永远也不需要进行**保护性拷贝。**实际上，你根本无需做任何拷贝，因为这些拷贝始终等于原始的对象。因此，你不需要，也不应该为不可变类提供`clone`方法或则拷贝构造器。这一点在Java平台的早期并不好理解，所以`String`类仍然具有拷贝构造器，但是应该尽量少用它。

不仅可以共享不可变对象，甚至还可以共享它们的内部信息。例如，`BigInteger`类内部都使用了符号数值表示法。符号用一个`int`类型的值来表示，数值则用一个`int`数组表示。`negate`方法产生一个新的`BigInteger`，其中数值是一样的，符号则是相反的。它并不需要拷贝数组，新建的`BigInteger`也指向原始数组中同一个内部数组。

```java
public BigInteger negate() {
        return new BigInteger(this.mag, -this.signum);
    }
```

不可变对象为其他对象提供了大量的构建，无论是可变的还是不可变的对象。如果知道一个复杂对象内部的组件不会改变对象，要维护它的不变性约束时比较容易的。这条原则的一种特例在于，不可变对象构成了大量的映射键和集合元素；一旦不可变对象进入到映射或则集合中，尽管这破坏了映射或则集合的不变性约束，但是也不用当心它们的值会发生变化。

不可变对象无偿的提供了失败的原子性。它们的状态是永远不变，因此不存在临时不一致的可能。

不可变类真正唯一的缺点是，对于每个不同的值都需要一个单独的对象。创建这些对象的代价可能很高，特别是大型的对象。例如，假设你有一个上百万位的`BigInteger`，想要改变它的低位：

```java
BiggInteger moby = ...;
moby = moby.flipBit(0)
```

`flipBit`方法创建了一个新的`BigInteger`实例，也有上百万位长，他与原来的对象只差一位不同。这项操作所消耗的时间和空间与`BigInteger`的成正比。我们拿它与`Java.util.BitSet`进行比较。与`BigInteger`类似，`BitSet`代表一个任意长度的位序列，当是与`BigInteger`不同的是，`BitSet`是可变的。`BitSet`类提供了一个方法，允许固定时间内改变此“百万位”实例中单个位的状态。

```java
BitSet moby = ...;
moby.flip(0);
```

如果你执行的一个或多个步骤的操作，并且每个步骤都会产生一个新的对象，除了最后的结果之外，其他的对象最终都会被丢弃，此时性能问题就会显露出来。处理这种问题有两种办法。第一种你办法，先猜测一下经常会用到的哪些多步骤的操作，然后将它们作为基础类型提供。如果多个步骤操作已经作为基本类型提供，不可变的类就无需再每个步骤单独创建一个对象。不可变的类在内部可以更加灵活。

如果能够精确的预测出客户端将要在不可变的类上执行那些复杂在的多阶段操作，这种包级私有的可变配套类的方法就可以工作的很好。如果无法预测，最好的办法是提供一个公有的可变配套类。在Java平台类库中，这种方法的主要例子是`String`类，它的可变配套类是`StringBuilder`。

现在已经知道了如果构建一个不可变的类，并且了解了不可变性的有点和缺点，现在我们来讨论其他的一些设计方法。前面提到过，为了确保不可变性，类绝对不允许自身被子类化。除了“使类成为`final`的”这种方法之外，还有另一种更加灵活的办法可以做到这一点。不可变的类变成`final`的另一种方法就是，让类的构造器都变成私有的或则包级私有的，并且添加公有的静态工厂来代替公有的构造器，为了具体说明这种方法，下面以`Complex`为例，看看如何使用这种方法：

```java
public final class Complex {
    private final double re;
    private final double im;

    private Complex(double re, double im){
        this.re = re;
        this.im = im;
    }
    
    public static Complex valueOf(double re, double im){
        return new Complex(re, im);
    }
		...
}
```

这种方法虽然并不常用，但它通常是最好的替代方法。它最灵活，因为它允许使用多个包级私有的实现类。对于处在包外部的客户端而言，不可变的类实际上是`final`的，因为不可能对来自另一个包的类、缺少公有的或受保护的构造器进行扩展。除了允许多个实现类的灵活性之外，这种方法还使得有可能通过改善静态工厂的对象缓存能力，在后续的发行版本中改进该类的性能。

开头关于不可变类的诸多规则指出，没有方法会修改对象，并且它的所有域都必须是`final`的。实际上，这些规则比真正的要求更强硬一点，为了提高性能有所放松。事实上应该是这样：没有一个方法能够对对象的状态产生**外部可见**的改变，然而，许多不可变的类拥有一个或者多个非`final`的域，它们在第一次被请求执行这些计算的时候，把一些开销昂贵的计算结果缓存在这些域中。如果将来再次请求同样的计算，就直接放回这些缓存的值，从而节约了重新计算过所需要的开销，这就是**延迟初始化**。

总之，坚决不要为每一个`get`方法编译一个相应的`set`方法。除非有很好的理由要让类成为可变的类，否则它就应该是不可变的。不可变的类有许多优点，唯一的缺点是在特定的情况下存在潜在的性能问题。你应该总是使用一些小的值对象，比如`PhoneNumber`和`Complex`，成为不可变的。（在Java平台类库中，有几个类中，有几个类如`java.util.Date`和`java.awt.Point`，它们本应该使不可变的，但实际确不是。）你也应该认真考虑把一些较大的值对象做成不可变的，例如`String`和`BigInteger`。只有当你确认有必要实现令人满意的性能时，才应该为不可变的类提供共有的的可变配套类。

对于某些类而言，其不可变性是不切实际的。如果类不能被做成不可变的，仍然应该尽可能地限制它地可变性。降低对象可以存在的状态数，可以更容易地分析该对象地行为，同时降低出错地可能性。因此，除非有令人信服地理由使域变成非final地，否则让每个域都是非final地。结合这条建议和15条地建议，你自然倾向于：除非有令人信服地理由要使域变成非final的，否则要使每个域都是private final的。

构造器应该创建完全初始化的对象 ，并建立起所有的约束关系。不要在构造器或者静态工厂之外再提供公有的初始化方法，除非有令人信服的理由必须要这么做。同样的，也不应该提供“重新初始化”方法（它使得对象可以被重用，就好像这个对象是由另一不同的初始状态构造出来的一样）。与所增加的复杂性相比，“重新初始化”方法通常并没有带来太多的性能优势。

通过`CountDownLatch`类的例子可以说明这些原则。它是可变的，但是它的状态空间被有意的设计得非常小。比如创建一个实例，只使用一次，他的任务就完成了：一旦定时的计数器达到零，就不能重用了。