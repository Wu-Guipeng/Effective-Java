# 第86条：谨慎地使用Serializable接口

想要适宜各类的实例可被序列化，非常简单，只要在他的声明中加入implements Serializable字样即可。正因为太容易，所以普遍存在这样一种误解，认为程序员毫不费力可以实现序列化。二实际的情形要复杂的多。虽然使一个类被序列化的直接开销非常低，甚至可以忽略不计，但是为了序列化而付出的长期开销往往是相当高的。

实现Serializable接口而付出最大代价是，一旦一个类被发布，就大大降低了【改变这个类的实现】的灵活性。如果一个类实现了Serializable接口，它的字节流编码（或者说序列化形式）就变成了它的导出的API的一部分。一旦这个类被广泛使用，往往必须永久支持这种序列化形式，就好像你不需要支持导出的API的所有其他部分一样。如果不努力设计一种自定义的序列化形式（custom Serializable form），而仅仅接受了默认的序列化形式，这种序列化形式将被永远束缚在该类最初的内部表示法上。换句话说，如果接受了默认的序列化形式，这个类中私有的和包级私有的实例域都将变成导出的API的一部分，这不符合【最低限度地访问域】的实践准则，从而它就失去了作为信息隐藏工具的有效性。

如果接受了默认的序列化形式，并且以后又要改变这个类的内部表示法，则结果可能导致序列化形式的不兼容。客户端出程序企图用这个列的旧版里序列化一个类，然后用新版本进行反序列化，结果将导致程序失败。反之亦然。在改变内部表示法的同时仍然维持原来的序列化形式（使用ObjectOutputStream.putFields和ObjectOutputStream.readFields），这也是可能的，但是做起来比较困难，并且会在源代码中留下一些明显的隐患。因此，应该仔细地设计一种高质量的序列化形式，并且在上时间内都愿意使用这种形式。这样做将会增加开发成本；但是设计不好的序列化形式则可能会使类根本无法演进。

序列化会使类的演变收到限制，这种限制的一个例子与流的唯一标识符（stream unique identity）有关，通常称它为序列版本UID（serial version UID）。每个可序列化的类都有一个标识号域它相关联。如果你没有在一个名为serialVersionUID的私有静态final的long域中显示地指定该标识号，系统就会对这个类的结构运用一个加密的散列函数（SHA1），从而在运行时自动产生该标识号。这个自动生产的值会受到类名称、它所实现的接口的名称，以及所有公有的和受保护的成员的名称所影响。如果你通过任何方式该变了这些信息，比如，增加了一个不是很重要的工具方法，自动产生的序列版本UID也会发生变化。因此，如果你没有声明一个显示的序列版本UID，兼容性建辉遭到破坏，在运行时导致InvalidClassException异常。

实现Serializable的第二个代价是，它增加了出现bug和安全漏洞的可能性（详见第85条）。通常情况下，对象是利用构造器来创建的；序列化制剂是一种语言之外的对象创建机制（extralinguistic mechanism）。无论你是接收了默认的行为，还是覆盖了默认的行为，方序列化机制（deserialization）都是一个【隐藏的构造器】，具备与其他构造器相同的特点。因为反序列化机制中没有显示的构造器，所以你很容易忘记要保证：反序列化过程必须要保证所有【由真正的构造器建立起来的约束关系】，并且不允许攻击者访问正在构造过程的对象的内部信息。依靠默认的反序列化机制，很容易使对象的约束关系遭到破坏，以及遭受非法访问（详见第88条）。

实现Serializable的第三个代价是，随着类的发行新的版本，相关的测试负担也会增加。当一个可序列化的类被修订的时候，很重要的一点是，要检查是否可以【在新版本中序列化一个实例，然后在旧版本中反序列化】，反之亦然。因此，测试所需要的工作量与【可序列化的类的数量和发行版本号】的乘积成正比，这个乘积可能会非常大。你必须即要确保【序列化-反序列化】过程成功，也要确保结果产生的对象真正是原始对象的复制品。如果在最初编写一个类的时候，就精心设计了自定义的序列化形式，测试的要修就可以有所降低。

实现Serializable接口并不是很轻松就可以做出的决定。如果一个类将要加入到某个框架中，并且该框架依赖于序列化来实现对象传输或者持久化，对于这个类来说，实现Serializable接口设就非常有必要。更进一步来看，如果这个类要成为另一个类的一个组件，并且后者必须实现Serializable接口，若前者也实现了Serializable接口，它就会更易于后者使用。然而，有许多实际的开销都与实现Serializable接口有关。每当你发现一个类的时候，都需要权衡一下所付出的代价和带来的好处。根据经验，如果BIgInteger和Instance等值类应该实现Serializable接口，大多数的集合类也应该如此。代表活动实体的类，如线程池（thread pool），一般不应该实现Serializable接口。

为了继承二设计的类应该竟可能少地去实现Serializable接口，用户的接口也应该尽可能少继承Serializable接口。如果违反了这条规则，扩展这个类或者实现这个接口的程序员就会背上沉重的负担。然而在某些情况下违反这条规则却是合适的，例如，如果一个类或者接口存在的目的主要是为了参数到某个快加中，该框架要求所有的参与者都必须实现Serializable接口，那么，对于这个类或者接口来说，实现或者扩展Serializable接口就是非常有意义的。

为了继承而设计的类中，真正实现了 Serializable接口的有Throwable和Component类。因为Throwable类实现了Serializable接口，所以RMI的异常可以从服务器端传到客户端。Component类实现了Serializable接口，因此GUI可以被发送、保存和恢复，但是即使在Swing和AWT的鼎盛时期，这个机制在实践中也鲜被使用。

如果实现一个带有实例域的类，它是可序列化和可扩展的，就应该担心一下几个风险。如果类的实例域值有一写约束条件，重要的是防止子类覆盖finalize方法，类只要通过覆盖finalize并把它什么为final便可以完成这个任务。否则，类就很容易受到终结器的攻击。最后，如果类有限制条件，当类的实例域被初始化的成它们的默认值（整数类型为0，boolean为false，对象引用类型为null）时，就会违背这条约束条件，这时候就必须给这个类添加readObjectNoData方法。

```java
private void readObjectNoData() throws InvalidObjectException{
	throw new InvalidObjectException("Stream data required");
}
```

Java 4版本就增加了这个readObjectNoData方法，还包含一一些冷僻的用例，包括给现有的可序列化类添加可序列化的超类。

有一条告诫与【不要实现Serializable接口】有关。如果一个专门为了继承而设计的语言的类不是可序列化的，那么想要编写出可序列化的子类就非常费力。这种类正常的反序列化就要求超类得有一个可访问的无参构造器。如果没有提供这样的无参构造器，子类就会被迫使用序列化代理模式。

内部类（详见第24条）不应该实现Serializable接口。它们使用编译器产生的合成域来保存指向外围实例的引用，以保存来自外围作用域的局部变量值。【这些域如果对应到类定义中】并没有明确的规定，就好像没有指定匿名类和局部类的名称一样。因此，内部类的默认序列化形式是定义不清楚的。然而，静态成员类却是可以实习Serializable接口。

简而言之，千万不要认为实现Serializable接口会很容易。除非一个类只在受保护的环境下使用，在这里版本之间永远不会交互，服务器永远不会暴露给不可信任的数据，否则，实现Serializable接口就是个很严肃的承诺，必须认真对待。如果一个类允许继承，则更要加倍小心。